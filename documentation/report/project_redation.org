Semester Project : Spring 2015
SDN assisted DMM
Project Report, 
======================================================================

* Part II

*** TODO matching criterias
*** TODO action & instructions , priority 
*** TODO pushing flows vs ponctual orders 
*** TODO flow gathered in table, table relachionship (general)
    

* Part III Project Implementation
* ----------------------------------------------------------------------

* 3.1 Enhance a simple switch in a real router
** Introduction
The implementation of the SDN controler, has been written from the
code of simple_switch.py provided in the Virtual Machine dirstibuted
by SDNhub.com. The initial code is quite limited and allows a switch
to handle message (only icmp echo reply and request) forwarding between
hosts directely linked to it. Then to improve the code to get a
controller able to achieve the previously described DMM solution the
first step is to enable the controller with router capabilities which
involves making it aware of the underlaying topology, making it handle
the icmpv6 control messages received by the switches and then making
it order switches to forward packets across the network. Those steps
are respectively described below.

** 3.1.1 Discovering network topology
*** DONE Retrieving network backbone's topology

Ryu controller to access the underlying network topology including
nodes and the links between them, then it has to be launched with the
"--observe-link" option. In order to build data structures where
topology information are stored, the controller uses the LLDP messages
exchanged between switches when the network is just created. That is
why this option allows the controller to be aware of all the switches
of the network and all the links between then but it can't retrieve
any information about the hosts.

An important point is as we didn't find any way to find out when the
discovery procedure was done, (ie detecting the instant when the
topology data structures are fully completed by Ryu), our controller
waits for the report of the reception of the first IPv6 message by one
of the switches of the network to start reading into those data
structures and building objects. Indeed we assume that IPv6 messages
are exchanged long time after the whole network discovery has been
done.

Our Ryu controller embed a function called collectRoutingInfo() that
has been created in the purpose of grabbing topology details and
information given by mininet obtained during the discovery phase.  It
is then called once, when the first IPv6 message is submitted by a
switch to the controller and uses the topology module of Ryu. Mininet
information are collected this way:

**** TODO code listing
         #All the topology information are obtained from the app_manager
        appManager = app_manager.RyuApp()
        #Collecting switches and links information
        self.switchList = ryu.topology.api.get_all_switch(appManager)
        self.linkList = ryu.topology.api.get_all_link(appManager)

Two lists : self.switchList and self.linkList are filled up, with
respectively switch and link objects. Those objects embed many
attributes that turns out to be useful for the controller in the
following parts that is why they are stored this way and not in only
keeping their identifier or reference.

*** DONE Setting up a virtual adressing plan

Mininet may assign MAC and IP address to every node of the constructed
network but since we wan't all the configuration decisions to be made
by the controller, it will re-define virtually all the IP and MAC
addresses of the network. "Virtually" meaning that new given addresses
are not written back on switchs interfaces to update the old ones but
when the controller asks a node to send a packet it will also specify
source and destination addresses the switch has to set on the packet
and thoses addresses will be the ones it has defined itself.

Then, once every connection between every switch is registered, the
collectRoutingInfo() function defines new IPv6 addresses and uses a
dictionnay called bindingList to store what is the new assigned IPv6
address to each interface of each switch (the key is the tuple formed
by the switch identifier and the interface identifier among the switch
and the value is the assigned IPv6 address). New addresses depend on
the identifiers of the switch itself, on the interface number and also
on the identifier of the switch on the other side of the link.

Here is the code filling up the bindingList structure from the linkList
and the switchList previously built.

**** TODO insert Listing
        for link in self.linkList:
            if (link.src.dpid,link.src.port_no) not in self.bindingList and (link.dst.dpid,link.dst.port_no) not in self.bindingList :
                self.bindingList[link.src.dpid,link.src.port_no] = '2000:'+str(link.src.dpid)+str(link.dst.dpid)+'::'+str(link.src.dpid)
                self.bindingList[link.dst.dpid,link.dst.port_no] = '2000:'+str(link.src.dpid)+str(link.dst.dpid)+'::'+str(link.dst.dpid)

Mac Addresses are also redifined the same way but as they all are
generated the same way, they are not stored anywhere but computed on
the fly every time they are needed. Here is the function that
construct them:

**** TODO insert listing
    #return the MAC address associated to DATAPATH_id and port_id
    def generateMAC(self, dpid, portid):
        addMAC = 'a6:0'+str(dpid)+':00:00:00:0'+str(portid)
        return addMAC

The way address are forged depend on the interfaces to which they are
assigned, indeed interfaces domain can be divided in two partitions,
the backbone interfaces and the local network interfaces. The first
one corresponds to interfaces in which a link between two switches is
pluged, and the second one corresponds to interfaces in which a link
between a switch and a host is pluged. Backbone interfaces all share
the same two bytes prefix : '2000:' and backbone interfaces connected
by a link share the same four bytes prefix : '2000:AB' where A and B
are the switch to which interfaces belong (order or A and B depends on
the link object from ryu.topology module). Then the last two bytes of
the address is defined by the interface number among the switch. For
example if we considere the third interface of a switch number 2
through which the switch linked to switch number 5, interface's address 
is 2000:25::3.

Then this addressing convention introduces a limit of the number of
switch that can handle the controller, as the identifier of two
switches must fit in two bytes for backbone addresses creation, and
since indentifiers are kept in decimal system (not hexadecimal) an
identifier can't exceed the value of 99, therefore it is not possible
to have more than 99 switches on the network.

Since local network interfaces are not discovered yet by the controler
as they are not registered on ryu.topology module's data structure,
the controler can't assign them addresses right now.

Just after address assignement another data struture is built, it's
called networkGraph, it's a dictionnary binding each switch to its
switch neighbor list. For this structure routing algorithm are
launched to resolve the one hop path to reach one switch from another
one.

Here is a example of addressing plan following the addressing
convetions described above:

**** TODO insert picture of network addressed map

** 3.1.2 Handling ICMPv6 configuration messages
*** DONE Introduction (may be temporary)
This initialization work described in the previous part is done when
the controller is sollicitated for the first time by a switch whih has
received an IPv6 packet. Once completed the received packet has to be
handled as well as the next incomming ones. Then when the controller
is reported of the reception of a IPv6 packet by a switch, it first
figures out the type of the packet and after run the apropriate
instructions.

Our controller only works with ICMPv6 messages, other kinds of
messages are filtered out.

*** DONE Router Solicitation message

The first type of message of a switch can receive is ICMPv6 Router
Solicitation messages, those one are sent by hosts when they get there
interface turned on or when they access to a new network. 

What the controler does first in this case is checking if the ingress
interface is not already registered as a backbone interface, if it is
the controller does nothing. Otherwise handling keep going and as now
controller is sure that the source is a host, it register its MAC
address (obtained from the source address field of the frame
containing the Router Solicitation Message) in a data strucure called
coveredHosts. It stores hosts that have registered inside the
subnetwork of each switch, in other words it stores for each switch
the hosts that are suposed to be linked to it. This structure is a
dictionnary of dictionnaries : the first level key is the switch
identifier and is bound to a dictionnary where keys are IPv6 addresses
that the hosts has forged while joining the sub-network and values are
the couple host's MAC address and the number of the switch's interface
that is linked to the host (to make things clear hear is an example:
{dpid1 : {host1IP:(host1MAC,intfLocal1),host2IP:(host2MAC,intfLocal2)}
, dpid2 : {host3IP:(host3MAC,intfLocal1)} }. 

An important point is since the host doesn't have any IPv6 address
yet, the one it will generate from IPv6-autoconfiguration process is
guessed from its MAC address and from the switch sub-domain in which
the it is. It is important to have in mind that if the host uses a
different way to forge its Global IPv6 address, the controller won't
recognize it.

The bindingList is also extended, indeed if the Router Solicitation
message is received on an interface nerver used before, as the
controler just discovers it, it stores the interface in the
coveredList: now its knowledge of the network topology gets extended
to local network interfaces and hosts to which they are linked. Then
as before an IPv6 address is assigned to this new discovered interface
and the controler has also a convention for local network
interfaces. The 2 bytes prefix of the address depends on the switch,
indeed switches define sub-domain among the network, but the first
half-byte of the prefix is always set to 2. Then the last two bytes of
the address is like before, defined by the interface number among the
switch. For example is the fourth interface of switch number 7 through
which the switch is linked to an host, interface's address is 2007::4.
If the Router Advertisement reaches an already registerd interface,
nothing described happens on the bindingList.

This is just after this step that the mobility management is done,
the controler finds out if the host that has sent the Router
Solicitation message cames from another sub-network and trigger or
not mobility management procedure. For the moment we will skip this
part, considering first a controler that make the network behaves
normally, without any extra mecanism.

Last, the controller forges the ICMPv6 Router Advertisement to be sent
by the solicited switch to the host that just contacted it, it first
create the core of the message this way: 

**** TODO insert Listing
icmp_v6 = icmpv6.icmpv6(type_=icmpv6.ND_ROUTER_ADVERT,
data=icmpv6.nd_router_advert(ch_l=64, rou_l=4,
options=[icmpv6.nd_option_pi(length=4, pl=64, res1=7, val_l=86400,
pre_l=14400, prefix=prefix)]))

with the variable prefix set to the switch's local network interface
IPv6 address to which the host is bound. This packet is then
encapsulated in a IPv6 packet (with source address set to the local
scope address of the interface, generated on the fly like MAC
addresses) and in a ethernet frame and is forwarded to the switch. 

As we want every Router Solicitation messages to be reported by the
switches to the controler in order to keep track of hosts moves across
the network, no flow handling Router Solicitations messages are pushed
down to the switch but only a ponctual order asking to forward the
provided Router Advertisement message on the specified interface.

Here is the associated code of a ponctual order embedding a Router
Advertisement message (under pck_generated name) sent by the controler
to the switch (called datapath here):
**** TODO insert listing
actions = [parser.OFPActionOutput(out_port)] 
out_ra = parser.OFPPacketOut(datapath=datapath,
buffer_id=ofproto.OFP_NO_BUFFER, in_port=0, actions=actions,
data=pkt_generated.data) 
datapath.send_msg(out_ra)

The switch will execute the given order in forwarding to the host the
Router Advertisement message and will keep reporting any Router
Solicitation messages comming next to the controler.

*** DONE Neighbor Solicitation message

A second kind of ICMPv6 message that can be reported by switches to
the controller are ICMPv6 Neighbor Solicitation messages, there are
two reason for an host to send such a message to its local switch. The
first one is in order to resolve the MAC address associated to a given
IPv6 address : the target address. In this case the option field of
the Router Solicitation message is not empty, and the controller
checks if the target address is one of the virtually assigned
addresses the solicited switch's interfaces. If yes the controler
forges the corresponding Neighbor Advertisement message that contains
the IPv6 address of the spotted interface and transmits it back to the
switch along a forwarding order for being relayed to the host, exactly
as for Router Advertisement messages.

As several hosts can be connected to the same switch and then get
configured with the same prefix whereas they are linked through
different interfaces, the controler also resolves inside domain
requests : when a Neighbor Solicitation messages received by a switch
has a target address corresponding to one of another host on the local
network. Here, as every packet between hosts in the sub-network goes
through the switch, the packet containing frame built by the sender
will have its destination MAC address set to the MAC address of the
switch's interface it is linked to.

If the option field of the Neighbor Solicitation message is null that
means that it has been sent by the host for address conflict
resolution purposes, in this case, as address conflicts are not
considered, the controller doesn't do anything : all the host
registration process inside controller data structure is done at
Router Solicitation message reception.

As address conflicts are not handled by the controller, if an host
comes up with a new reconfigured IPv6 address it won't be recognized
by the switch since this address is not obtained from the usual IPv6
autoconfiguration process.

Router Solicitation and Neighbor Solicitation messages are the only
two kinds of ICMPv6 control messages handled by the controller, as the
controler redefines itself the whole backbone addressing plan and as
address conflict is not managed there is no need to care about ICMPv6
Router Advertisement and Neighbor Advertisement Messages.

** 3.1.3 ICMPv6 Echo request & reply
*** TODO 1 ping toward one of the router intf : scanning bindingList of the switch : no flow pushed, just ponctual order
*** TODO 2 ping toward local host : seeking in coveredHost
*** TODO 3 ping toward another entity : other switch backbone intf / local nw intf ,remote host finding next hop and output intf : flow pushed 
For the previous messages that involve a response from the switch,
as this response is build from elements contained in the request, it
is not possible or quite cumbersome to set up flows on the switches in
order to make those solicitations not go anymore through the
controller. Indeed the solution would constist in pushing flows
matching every single version of the Router or Neighbor solicitation
messages that could have been received. That is why it has been
choosen to make the switches forward every single solicitation to the
controller that forge the custom response messages and send them back
to the switches.

Echo request and response messages are also divided on different
categories but this time based on their destination. Indeed if the
message is addressed to one of the switch's addresses, the controller
in case of echo request, forges the response and forward it to the
switch (no flows are pushed down here). 

If the destination address is not one the switch, the controller
checks it's domain and figures out either if the message has to be
send on the switch's local interface of has to be forwarder to another
switch, precisely the one that host the destination domain. Indeed
since our controller impose to have a stricly related newtork of
switches there is at most two switches between two hosts. Here for the
first time flow are pushed to the switch from the controler, they are
matching the received message and enable the switch to forward
autonomously the next similar ping messages either on its local
interface using the registered hosts list to set the MAC destination
address or either toward another switch and where the output interface
had been resolved using a routing function explained in the next
part.

As the output interface resolving is based on the prefix of the
desination address, and since switch interfaces linked to other
switches have all the same prefix, a ping whose destination address is
a backbone interface (every interface but not the local one) of a
switch that is not the one hosting the ping sender can't be routed and
then forwarded.

** 3.1.4 Flow organisation 
*** TODO 1 routing related flows in table 1 anticipation of table 0
*** TODO 2 switches become autonomous

The last (but not least) functionnality that has to be provided to our
controller is make switches forward packets on the right output
interface according to packets' destination address. As the type of
network we are working on is simple : composed only by edges routers
all linked to each others and whose interface number 1 is dedicated to
their local network, packets switching is not a difficult operation.
The idea is to spot in the link list previously built the link between
the switch that has to forward the packet and to the one hosting the
destination address. The output interface is just the one where the
link is plugged on the first of those two switches.



As we previously saw the controller can gives order to a switch in two
different ways, either it specifies a punctual action either it pushes
a new flow to it. In this second case every packet matching the flow
received by the router won't be relayed to the controller but will be
treated as descibed by the flow. It's way for the controller not to be
sollicited for similar messages and repeat the same puncutal action to
carry out. Then when the first ping message of sequence is transmited
to the controller by a switch that doesn't know how to handle it, the
controller build flow that matches the destination address and the
type (icmpv6) of this ping message and which action is to forward on
the resolved output interface thanks to the routing function. Finally
this flow is pushed down to the switch that is now able to forward the
next similar ping messages without refering to the controller.

OpenFlow allows flows to be grouped into ordered tables and then to
link those tables together, then we define 2 tables : the first one,
(table number 0) is dedicated to flows related to mobility handling
and for which the default entry policy is forwarding to the second the
second table (table number 1) which is dedicated to the flow related to
classic message forwarding.  Then for each switch, when a packet is
received, it checks if it matches one of the entry of the first table,
if not it checks if it matches one of the entry of the second table,
if not the packet is transfered to the controller. If a packet matches
an entry the associated action is carried out and the next packet is
treated.

Then our routing flows just build up which indicate to the switch
the forwarding interface for a given destination address are pushed to
the second flow tables of the switches, and the first one remains
empty for the moment.


Once all this functionnalities described untill now are implemented in
the controller, switches are now able to forward ping exchanges
between any nodes of the network. That is the first step for our
controler, and now it has to be enhanced with mobility management
capabilities.

* 3.2 Handle host mobility across the network
** Introduction
Host mobility is ensured first in keeping track of them all across the
network, indeed the list of the previously visited networks is stored
for each host, so that when a host gets to a new network, all the old
ones registered on the list are involved in the mobility management
procedure.

** 3.2.1 Detecting New host and retrieving its history
*** TODO 1 mobility management treatment at router sol. reception : from its Trace

When a host gets connected for the first time to a switch it sends a
router solicitation message, those messages are relayed to the
controller that checks the MAC source address in order to figure out
the identity of the host. Thanks to the mobility module, the
controller keeps in memory a dictionnary where every host identifier
is linked to the list of networks the host has visited.  If the last
network of this list is the same as the one where the router
solicitation comes from, that means that the host hasn't moved then no
mobility management procedure is triggered.

*** TODO 2 populating 3rd table to make the new switch know the local intf of the old @, not interferring with normal routing (as default policy of t1 is delete)
** 3.2.2 Setting up tunnels
*** TODO 1 tunnel aim and properties : vlan (why?), unidirectionnel
*** TODO 2 implementation using flows : old input, new output : ok (@ip retrieving) / old output : table 0 / new input : table 3 ; tables relashionnship 
   
When a host is detected as having moved from one network to another, a
mobility management procedure is launched constisting in building a
tunnel between the switch responsible of the network currently visited
by the host and each of the previously visited network's switch. In
this way all the messages addressed to an address that the host has
forged in a old network will be forwarded in the host's current
network. In the reverse direction, when the host sends a message with
a old IP address as source address, this message is tunneled to the
switch controling the newtork where this old address has been built
(no route optimization) before been forwarded toward the final
destination.

*** TODO 3 switches crossed by the tunnel relaying node.
*** a. Properties:

It has been choosen to implement those tunnels with Vlan tags, as it
only deals with the layer 2, it makes things easiers for switches.
Moreover tunnels are shared between hosts, only one tunnel exists
between two given switches for a given direction, through which are
exchanged messages concerning all the hosts with mobility service
involving those two switches. The first host that goes from a network
A to a netork B will trigger the establishment of a tunnel between the
associated switches and every next host that do the same crossing from
A to B will have its message going conveyed through this same
tunnel. Tunnels are unidirectionals in the sense that they convey
messages (in both directions) to ensure mobility for a host from a
network A to a newtork B, if the host goes back to A from B another
tunnel will be used.

*** b. Implementation:

A tunnel between a previously visited network switch A and the
currently visited newtok switch B is set up by the controller in
pushing two flows, this time related to hosts mobility, first the to
the first table of switch A:

    The first one matches packets coming from the network whose
    destination address is the one the Mobile Node forged when it was
    in network A. The associated action is pushing a VLAN tag with a
    given value on those packets, changing MAC addresses and
    forwarding packets to router B.

    The second one matches packets coming directly from router B and
    encapsulated in a VLAN whose tag has the same value as the one
    used before. The first action consists in getting rid of the VLAN
    tag and then in relaying the new packet over the the second table
    so that it will be examined like a normal packet from the local
    network and be routed as usual to the external network.

Then two other flows are pushed to the first table of router B:

    The first one matches all the received packet on the local network
    interface whose source address is the one of the Mobile Node
    forged when it was in network A. The associated action is to push
    a VLAN tag with the same value as before, to change MAC addresses
    and then to forward packets to router A.

    The second one matches packets from router A that include a VLAN
    tag with the same value as before. The associated action consists
    in stripping VLAN tag, changing MAC addresses and forwarding packets
    on the local interface.

The value used for the VLAN tag then depends only on routers A and B,
then different packets from different communications will be tagged
with the same value between A and B.

** 3.2.3 Advanced mobility

It's important to keep in mind that the mobile host may not only go
from one network to another but may roam across many different ones
and also go back to previously visited network. Therefore the tunnel
establishement algorithm described before is a trade between having a
simple sequence of operations to be done by the controller and try not
to make switches flow table soaring after host have roamed for a
while, that is why shared tunnel solution has be selected.

**** a. Subsequent Handover

When the mobile node after having left its home network A to go to
network B, changes again of network and goes to network C. There are
now two address for which mobility have to be ensured : the one
acquired in network A and the one acquired in B, that means that two
tunnels have to be set up : one between switch A and switch C and
another between switch B and switch C, moreover the previously tunnel
from A to B must not be used anymore for handlin mobility of this
mobile node. Once installed into a switch a flow can be updated when a
new flow whith the same matching criterias is pushed to the switch,
this is what happens when the host gets to network C. At this time two
tunnel flows are installed into switch A : one ensures that every
packet going to the mobile node address is forwarded in a vlan tunnel
toward B, let's call this flow FA1. The other one ensures that every
packets going from the vlan tunnel is piped to the routing table,
let's call it FA2. When the mobile node reaches network C, a new vlan
tunnel is set up between switches A and C, FA1 is then updated because
a new flow matching every packets going to mobile node address is
pushed, and makes the switch A forwards them into the new vlan-tunnel
toward C. The second new pushed flow matches packets based on a new
vlan tag, then it doesn't update FA2 as tunnels between A and B and
between A and C use different tag. Then switch A has now 3 flows in
its tunnel flow table : two of them handle host mobility into network
C and the last one is now useless for the considered host but still
important to handle mobility of other mobile nodes that have moved
from network A to network B.

The two new flows pushed to switch B when the mobile node gets in
network C are exactely analog to the one pushed to switch A when the
host moved to network B, but they are associated with the new vlan
tunnel between switch B and switch C. One of the two already existing
flows related to the vlan tunnel established with switch A, was in
charge of forwarding packets caming from the tunnel to network B
interface, let's call it FB1. The other one was matching packets with
mobile node address as source address and sending them into the
tunnel, let's call it FB2. As the mobile node is not anymore in
network B, FB2 becomes completely useless, but FB1 is still used for
other mobile nodes that have moved from network A to network B.

Two pairs of flow are then pushed to switch C they are analog to the
pair pushed to switch B when the mobile node reached network B from
network A, but one pair is related to the tunnel between switch A and
switch C and the other to the tunnel between switch B and switch C.

**** b. Complexity:

In this scenario of subsequent handover, when the node gets to network
C, 8 flows are pushed by the controller, and every time a mobile node
moves to a new network, n time 4 flows will be pushed with n the
number of visited networks. Indeed the fact of having simple flow
pushing algorithm makes the number of OpenFlow messages quite
important. However, our method doesn't present a great space
complexity regading to switches flow tables, and especially for the
first flow table. Indeed as tunnel are shared, pushed flows are still
usefull for other mobile node except the previously called FB2 which
becomes unused untill the mobile node is back to network B.

**** c. Back to a visited network 

If our mobile node, after having visited network C, keeps roaming and
goes back to network B, mobility of the the address acquired in
network A and of the one acquired in network C have to be ensured,
moreover packets going to the address that the mobile node has forged
in network B doesn't have to be transfered in a tunnel anymore.  Then
two flows are pushed to switch A and two others are pushed to switch B
and as they are exactly the same as the one pushed when the host moved
first from network A to network B (the vlan tag is still the same), there
won't have new flows in switch A and switch B's flow table.

Two other pairs of flow are pushed to switch C and switch B again,
but as we said tunnel are unidirectionnal in the sense that one
tunnel ensure mobility between two switch for a given direction, then
two more entries are written in both switch B and switch C's flow
table.

Packets going to the address that the mobile node forged into
newtork B when it got there for the first time were matched by a flow
entry that sent them into the tunnel between switch B and switch C.
Now this flow entry is updated with the push of a same matching flow
that forward packets on the local network interface of the switch.

**** d. complexity

When the mobile nodes goes back to a previously visited network, old
flow entries are used again, and then flow table size doesn't become
very high. As each mobile node is associated to the list of the
networks that he visited, if it goes back to previous networks,
several networks can occur multiple time on the list, then in order to
avoid subsequent flow pushing dealing with the same tunnel the
controller when handling mobile node handover, keeps in memory wich
tunnel has already be updated in order not to send flows updating an
already updated tunnel.

* 3.3 Observations and results 
** Introduction
This part is following the steps of what is suposed to be presented
during the final presentation, its role is to illustrate and make
clearer the concepts presented in the previous section.

** 3.3.1 Network topology and simple ping
*** a. Topology
Let's considere a strictly related newtork of 4 routers where each
one of them has a host linked to its local interface as shown below:
**** TODO INSERT NETWORK PLAN AND PROVIDE CODE IN APPENDIX
Once both mininet and the controller are launched, after few seconds
host get configured with global IPv6 addresses:
**** TODO insert picture h1_autoconfiguration.png
     
*** b. Simple Ping
To enable host to send messages, thay have to be given a default
route, here the local router is the default route, 
**** TODO insert picture hosts_routeConfiguration.png
From now hosts are able to ping each other, the first ping messages
won't be conveyed to their destination as the flow are getting pushed
to switches but once they received all the information from the
controller, messages are well relayed. Here is an example with h2
pinging h1's address : 
**** TODO insert picture h2_ping_h1.png


The first message of this series of ping has triggered flow pushing
to the second flow table of s1 and s2, at the begining those tables
were empty and now they get populated with the occurence of new ping
messages, here is the content of the flow tables of s2.
**** TODO insert s2_dumpflows.png

** 3.3.2 Simulating one hop mobility

As making hosts move from one router to another with mininet looks
possible to implement in a python script, but not with command line
instruction. The idea to overcome this issue is to use IP and MAC
spoofing inside the network. Indeed let's configure h3 with the same
addresses as h1 while h1 is turned of, as h3 presents h1 identifiers
the controller will treat it as if it was h1.

**** TODO insert h3_spoofs_h1.png

Now if h2 pings again h1's address, ping messages are still well
exchanged but now the ttl of the ping response is equal to 61 whearas
it was equal to 62 before, that means that there is one more hope now
on the path from h2 to h1's address. Using a packet sniffer it is
possible to see ping messages going from s2 to s1 and then being
relayed to s3, h1's address mobility is then provided.
**** TODO insert picture h2_ping_h1spoofed.png

Ping messages are now received and treated by h3 that now plays the
role of h1 as we can see from a packet capture on h3's interface:

**** TODO insert picture h3_tcpdump.png

Flow tables have been updated, the first flow table of s1 is now
containing two flows that transfer packets going to h1's address in
the tunnel toward s3.

**** TODO insert s1_dumpflows.png

** 3.3.3 Simulating advanced mobility

Let's now turn h3 off and make h4 impersonate h1 exactly as the same
way we did before with h3, the controller will then believe that h1
has now moved from s3 coverage to s4 coverage.  Then ping messages go
now through a new tunnel between s1 and s4, and second tunnel is set
up between s3 and s4, we can retrieve them with the dump of s4 flow
table:

**** TODO insert s4_dumpflows.png

When the mobile node moves back under s3 coverage after having
visited s4 network, flow tables are updates and ping messages are now
routed again to s3 and s3 now forwards packets going to h1'address
not anymore on a tunnel but on its local interface, here is s3 flow
table when h3 spoofes h1 again:

**** TODO insert s3_dumpflows.png  


* Part IV Futur Enhancements and Conclusion
* ----------------------------------------------------------------------

* 4.1 Enhancements
** 4.1.1 Network topology constrains
*** a. Stricly related switch backbone
A major enhancement of the current program would consist in making the
controller more open to different network topology, currently all the
switches of the network has to be linked together. This simplification
has been choosed in order to keep routing alorithm simple, but it's a
hypotesis that is quite far from real world network topology. In the
program the algorithm constists in finding the switch that host the
destination node thanks to the destination address of the packet, and
then find the interface to which the link leading to this switch is
plugged from the link table. 

A solution can be to have a topology with the shape of a star, with
one switch at the middle is linked to all the other around him, and
the surrounding switch just forward packets to it as if it was their
default gateway. There controller would have to care about the switch
it's dealing with because routing policies would't be the same for all
the switches.

*** b. Allow multiple local interface

A second constrain is that only the first interface of each switch
must be dedicated to its local network. As mininet doesn't allow two
hosts sharing the same switch interface, our program doesn't work with
a network where multiple host are behind the same switch.

Adding several local interfaces involve many changes on the program as
switches would have to resolve output interface for packets going to
hosts thay are hosting. If mobility is not ensured, it's simple but
for a given switch when packets are comming from a shared tunnel with
a destination address forged in another network, this switch has to
know how to route it toward the right local interface. But if the
same packet is comming to the switch but not through a tunnel this
packet has to be forwarded on the backbone, to the associated switch.
This involves to introduce two different and independant routing
rules, that can be done with a third table.

Moreover the case of an host that changes the interface to which it
is linked to a switch has to be handled, all the flows of the third
table related to host addresses would have to be updated.
 
*** c. Make the controller independant of interface order

Another optimisation that comes along with the previous one would be
to make the conrtroller completly independant with how switch
interface are configured if they are linked to other switches of host.
The one toward the switches can be obtained from the topology data
structure build by mininet and the other can be spotted out at the
reception of router or neighbor solicitation messages.

** 4.1.2 Controller algorithms 
*** a. Having less flow to push
We already said that each time a node moves to a new network after
having visited n networks, 4 time n flows has to be pushed down by the
controller. Then after a while it can turns out to be lot of flow to
send for the controller. In order to limit this number a new way to
handle mobility would be only to set up a tunnel between the switch
of the just network left by the host and the one of the newtork just
reached, then mobility would be ensured with this series of tunnel
bound one after the other one among which switches would forward
packets going to the address the mobile node has forged under their
coverage but also packets going to the address the mobile has forged in
the network visited before : comming from the serie of tunnel. 

*** b. Handling the first packets of flow
As routing flows are pushed reactively the first packets of a serie
that triggers a flow pushing are lost. This can be avoided in
implementing a buffering mechanism inside the controller or in making
it tell switches to forward those packets to their destination
while flows are being set up.

*** c. Handling other types than icmpv6
Flows pushed to both the first or the second flow table of each switch
match ipv6 ping messages packet, this has to be changed in the future
to allow other types of message to be treated. The question then is
gather all the network traffic type in one general matching flows or
assign specific flows for each supported protocol.

*** TODO d. Handle address confict within the same sub network
    with other host, we suppose that the node compute it global ip@
    the same way as the controller
*** d. Introducing access control to mobility service
As mobility management is presented as a service it would be nice to
control which user can use it. Then the implementation of a policy
decision an enforcement entity could be done which would be consulted
when a new user shows up in the network. The authentication can be
first based on the mac address, and then on more advanced criterias. 

** 4.1.3 Interaction with mininet
*** a. Make hosts move for real
Yet a way to make host moves from one switch to antother within the
mininet virtual network hasn't been found, that is why our way was to
trick the SDN controller with addresses spoofing. But as hosts doesn't
properly move in our simulation we do not really know how the system
really reacts and may be the messages exchanged between the mobile
node and the switch are not exactelly the same. It appears that
allocating several local network interfaces on switches may help but
this involve changes of the controller behaviour as described
before.

*** b. From comand line to a batch program
Our demonstration has been done in typing one by one all the mininet
instructions that turns out to be quite the same, it would make the
interaction with mininet easier and faster especially during the test
phases to load once an instruction file instead of writing them all
every single time. 
 
* 4.2 Conclusion
** 4.2.1 Status and scope of the program
what is it doing? limitation? why is it limited?
** 4.2.2 Context, how can it be used in real life 
** 4.2.3 Personal impressions
