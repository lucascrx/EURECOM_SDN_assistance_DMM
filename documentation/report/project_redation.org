Semester Project : Spring 2015
SDN assisted DMM
Project Report, 
======================================================================

* Part II

*** TODO matching criterias
*** TODO action & instructions , priority 
*** TODO pushing flows vs ponctual orders 
*** TODO flow gathered in table, table relachionship (general)


* Part III Project Implementation
* ----------------------------------------------------------------------

* 3.1 Enhance a simple switch in a real router
** Introduction
The implementation of the SDN controler, has been written from the
code of simple_switch.py provided in the Virtual Machine dirstibuted
by SDNhub.com. The initial code is quite limited and allows a switch
to handle message (only icmp echo reply and request) forwarding between
hosts directely linked to it. Then to improve the code to get a
controller able to achieve the previously described DMM solution the
first step is to enable the controller with router capabilities which
involves making it aware of the underlaying topology, making it handle
the icmpv6 control messages received by the switches and then making
it order switches to forward packets across the network. Those steps
are respectively described below.

** 3.1.1 Discovering the topology

*** DONE Retrieving network backbone's topology

Ryu controller to access the underlying network topology including
nodes and the links between them, then it has to be launched with the
"--observe-link" option. In order to build data structures where
topology information are stored, the controller uses the LLDP messages
exchanged between switches when the network is just created. That is
why this option allows the controller to be aware of all the switches
of the network and all the links between then but it can't retrieve
any information about the hosts.

An important point is as we didn't find any way to find out when the
discovery procedure was done, (ie detecting the instant when the
topology data structures are fully completed by Ryu), our controller
waits for the reception of the first IPv6 message by one of the
switches of the network to start reading into those data structures
and building objects. Indeed we assume that IPv6 messages are
exchanged long time after the whole network discovery has been
done.

Our Ryu controller embed a function called collectRoutingInfo() that
has been created in the purpose of grabbing topology details and
information given by mininet obtained during the discovery phase.  It
is then called once, when the first IPv6 message is submitted by a
switch to the controller and uses the topology module of Ryu. Mininet
information are collected this way:

**** TODO code listing
         #All the topology information are obtained from the app_manager
        appManager = app_manager.RyuApp()
        #Collecting switches and links information
        self.switchList = ryu.topology.api.get_all_switch(appManager)
        self.linkList = ryu.topology.api.get_all_link(appManager)

Two lists : self.switchList and self.linkList are filled up, with
respectively switch and link objects. Those objects embed many
attributes that turns out to be useful for the controller in the
following parts that is why they are stored this way and not in only
keeping their identifier or reference.

*** TODO 1 rewrite physical backbone addressing with a virtual addressing: MAC and IP @ filling up bindingList

Mininet may assign MAC and IP address to every node of the constructed
network but since we wan't all the configuration decisions to be made
by the controller, it will re-define virtually all the IP and MAC
addresses of the network. "Virtually" meaning that new given addresses
are not written back on switchs interfaces to update the old ones but
when the controller asks a node to send a packet it will also specify
source and destination addresses the switch has to set on the packet
and thoses addresses will be the ones it has defined itself.

Then, once every connection between every switch is registered, the
collectRoutingInfo() function defines new IPv6 addresses and uses a
dictionnay called bindingList to store what is the new assigned IPv6
address to each interface of each switch. New addresses depend on the
identifiers of the switch itself, on the interface number and also on
the identifier of the switch on the other side of the link.

Here is the code filling up the bindingList structure from the linkList
and the switchList previously built.

**** TODO insert Listing
        for link in self.linkList:
            if (link.src.dpid,link.src.port_no) not in self.bindingList and (link.dst.dpid,link.dst.port_no) not in self.bindingList :
                self.bindingList[link.src.dpid,link.src.port_no] = '2000:'+str(link.src.dpid)+str(link.dst.dpid)+'::'+str(link.src.dpid)
                self.bindingList[link.dst.dpid,link.dst.port_no] = '2000:'+str(link.src.dpid)+str(link.dst.dpid)+'::'+str(link.dst.dpid)

Mac Addresses are also redifined the same way but as they all are
generated the same way, they are not stored anywhere but computed on
the fly every time they are needed. Here is the function that
construct them:

**** TODO insert listing
    #return the MAC address associated to DATAPATH_id and port_id
    def generateMAC(self, dpid, portid):
        addMAC = 'a6:0'+str(dpid)+':00:00:00:0'+str(portid)
        return addMAC


Moreover each switches is supposed to have a local interface where its
local network is bound to, our controller imposes that it has to be
the interface number 1, then like before an IPv6 address is also
assigned to local interfaces:

        for switch in self.switchList:
            self.bindingList[switch.dp.id,1]='200'+str(switch.dp.id)+'::1'
            #initilizing coveredHosts dictionnary:

It's important to understand that all this generated IP address are
never known the switches, indeed the controller never transmit them
but the flows and the orders it will push the routers will be forged
according to this new addressing plan. Then all the addresses provided
by mininet or the netork simulator become useless and moreover, as you
can see later, switches MAC address are also virtually re-written the



*** TODO provide details on the addresing plan itself
*** implementing addressing plan


** 3.1.3 Handling ICMPv6 configuration messages
*** a. Router Solicitation message
**** TODO 1 register host and allow intf discovering too after checking : completing bindingList
**** TODO 2 covered host dictionnary built up , ipv6 address guessing au 
The first type of ICMPv6 a router is willing to receive is Router
Solicitation message, when one host gets bound to its local interface,
this message is forwarded to the controller since the switch doesn't
know how to handle it and since no flow matching this kind of message
is never ever pushed down to it. Then the controller first retrieves
the identity of the solicitating host thanks to its mac address, from
this, the controller checks if the host is comming from a previous
network and if its mobility has to be ensured and trigger or not the
mobility management procedure, this point will be explained in a later
in the report. Finally the controller forges a Router Advertisement
message that it transmits to the solicited switch in order to be
relayed on the local network interface. 

*** b. Neighbor Solicitation message
**** TODO 1 two type of NS only smth done when option field not null:node tries to resolve switch mac @
**** TODO 2 if NS for getting mac @ of another host in the same sub domains routers gives it own mac @
**** TODO 3 all the registration done at RS reception, not handling address
conflicts cases 

Then switches also forward to the controller the neighbor solicitation
messages that can be split up into subcategories.  An host can send a
neighbor solicitation in order to resolve the MAC address associated
to a given IP address, in this case the option field of the router
solicitation message is not empty, and the controller checks if the
target IP address is one virtually allocated addressses of the
solicited switch, if yes the controler forges the corresponding
neighbor advertisement message and transmits it to the switch for
being relayed. If the option field of the router solicitation message
is null that means that this messages has been sent by the host for
address conflict resolution purposes, in this case, as address
conflicts are not considered, the controller just registers the host
to the solicitated switch's covered hosts list.

**** TODO 4 other icmpv6 control msg not handled (RA,NA) as controller redesignes network topology 
** 3.1.4 ICMPv6 Echo request & reply
*** TODO 1 ping toward one of the router intf : scanning bindingList of the switch : no flow pushed, just ponctual order
*** TODO 2 ping toward local host : seeking in coveredHost
*** TODO 3 ping toward another entity : other switch backbone intf / local nw intf ,remote host finding next hop and output intf : flow pushed 
For the previous messages that involve a response from the switch,
as this response is build from elements contained in the request, it
is not possible or quite cumbersome to set up flows on the switches in
order to make those solicitations not go anymore through the
controller. Indeed the solution would constist in pushing flows
matching every single version of the Router or Neighbor solicitation
messages that could have been received. That is why it has been
choosen to make the switches forward every single solicitation to the
controller that forge the custom response messages and send them back
to the switches.

Echo request and response messages are also divided on different
categories but this time based on their destination. Indeed if the
message is addressed to one of the switch's addresses, the controller
in case of echo request, forges the response and forward it to the
switch (no flows are pushed down here). 

If the destination address is not one the switch, the controller
checks it's domain and figures out either if the message has to be
send on the switch's local interface of has to be forwarder to another
switch, precisely the one that host the destination domain. Indeed
since our controller impose to have a stricly related newtork of
switches there is at most two switches between two hosts. Here for the
first time flow are pushed to the switch from the controler, they are
matching the received message and enable the switch to forward
autonomously the next similar ping messages either on its local
interface using the registered hosts list to set the MAC destination
address or either toward another switch and where the output interface
had been resolved using a routing function explained in the next
part.

As the output interface resolving is based on the prefix of the
desination address, and since switch interfaces linked to other
switches have all the same prefix, a ping whose destination address is
a backbone interface (every interface but not the local one) of a
switch that is not the one hosting the ping sender can't be routed and
then forwarded.

** 3.1.5 Flow organisation 
*** TODO 1 routing related flows in table 1 anticipation of table 0
*** TODO 2 switches become autonomous

The last (but not least) functionnality that has to be provided to our
controller is make switches forward packets on the right output
interface according to packets' destination address. As the type of
network we are working on is simple : composed only by edges routers
all linked to each others and whose interface number 1 is dedicated to
their local network, packets switching is not a difficult operation.
The idea is to spot in the link list previously built the link between
the switch that has to forward the packet and to the one hosting the
destination address. The output interface is just the one where the
link is plugged on the first of those two switches.



As we previously saw the controller can gives order to a switch in two
different ways, either it specifies a punctual action either it pushes
a new flow to it. In this second case every packet matching the flow
received by the router won't be relayed to the controller but will be
treated as descibed by the flow. It's way for the controller not to be
sollicited for similar messages and repeat the same puncutal action to
carry out. Then when the first ping message of sequence is transmited
to the controller by a switch that doesn't know how to handle it, the
controller build flow that matches the destination address and the
type (icmpv6) of this ping message and which action is to forward on
the resolved output interface thanks to the routing function. Finally
this flow is pushed down to the switch that is now able to forward the
next similar ping messages without refering to the controller.

OpenFlow allows flows to be grouped into ordered tables and then to
link those tables together, then we define 2 tables : the first one,
(table number 0) is dedicated to flows related to mobility handling
and for which the default entry policy is forwarding to the second the
second table (table number 1) which is dedicated to the flow related to
classic message forwarding.  Then for each switch, when a packet is
received, it checks if it matches one of the entry of the first table,
if not it checks if it matches one of the entry of the second table,
if not the packet is transfered to the controller. If a packet matches
an entry the associated action is carried out and the next packet is
treated.

Then our routing flows just build up which indicate to the switch
the forwarding interface for a given destination address are pushed to
the second flow tables of the switches, and the first one remains
empty for the moment.


Once all this functionnalities described untill now are implemented in
the controller, switches are now able to forward ping exchanges
between any nodes of the network. That is the first step for our
controler, and now it has to be enhanced with mobility management
capabilities.

* 3.2 Handle host mobility across the network
** Introduction
Host mobility is ensured first in keeping track of them all across the
network, indeed the list of the previously visited networks is stored
for each host, so that when a host gets to a new network, all the old
ones registered on the list are involved in the mobility management
procedure.

** 3.2.1 Detecting New host and retrieving its history
*** TODO 1 mobility management treatment at router sol. reception : from its Trace

When a host gets connected for the first time to a switch it sends a
router solicitation message, those messages are relayed to the
controller that checks the MAC source address in order to figure out
the identity of the host. Thanks to the mobility module, the
controller keeps in memory a dictionnary where every host identifier
is linked to the list of networks the host has visited.  If the last
network of this list is the same as the one where the router
solicitation comes from, that means that the host hasn't moved then no
mobility management procedure is triggered.

*** TODO 2 populating 3rd table to make the new switch know the local intf of the old @, not interferring with normal routing (as default policy of t1 is delete)
** 3.2.2 Setting up tunnels
*** TODO 1 tunnel aim and properties : vlan (why?), unidirectionnel
*** TODO 2 implementation using flows : old input, new output : ok (@ip retrieving) / old output : table 0 / new input : table 3 ; tables relashionnship 
   
When a host is detected as having moved from one network to another, a
mobility management procedure is launched constisting in building a
tunnel between the switch responsible of the network currently visited
by the host and each of the previously visited network's switch. In
this way all the messages addressed to an address that the host has
forged in a old network will be forwarded in the host's current
network. In the reverse direction, when the host sends a message with
a old IP address as source address, this message is tunneled to the
switch controling the newtork where this old address has been built
(no route optimization) before been forwarded toward the final
destination.

*** TODO 3 switches crossed by the tunnel relaying node.
*** a. Properties:

It has been choosen to implement those tunnels with Vlan tags, as it
only deals with the layer 2, it makes things easiers for switches.
Moreover tunnels are shared between hosts, only one tunnel exists
between two given switches for a given direction, through which are
exchanged messages concerning all the hosts with mobility service
involving those two switches. The first host that goes from a network
A to a netork B will trigger the establishment of a tunnel between the
associated switches and every next host that do the same crossing from
A to B will have its message going conveyed through this same
tunnel. Tunnels are unidirectionals in the sense that they convey
messages (in both directions) to ensure mobility for a host from a
network A to a newtork B, if the host goes back to A from B another
tunnel will be used.

*** b. Implementation:

A tunnel between a previously visited network switch A and the
currently visited newtok switch B is set up by the controller in
pushing two flows, this time related to hosts mobility, first the to
the first table of switch A:

    The first one matches packets coming from the network whose
    destination address is the one the Mobile Node forged when it was
    in network A. The associated action is pushing a VLAN tag with a
    given value on those packets, changing MAC addresses and
    forwarding packets to router B.

    The second one matches packets coming directly from router B and
    encapsulated in a VLAN whose tag has the same value as the one
    used before. The first action consists in getting rid of the VLAN
    tag and then in relaying the new packet over the the second table
    so that it will be examined like a normal packet from the local
    network and be routed as usual to the external network.

Then two other flows are pushed to the first table of router B:

    The first one matches all the received packet on the local network
    interface whose source address is the one of the Mobile Node
    forged when it was in network A. The associated action is to push
    a VLAN tag with the same value as before, to change MAC addresses
    and then to forward packets to router A.

    The second one matches packets from router A that include a VLAN
    tag with the same value as before. The associated action consists
    in stripping VLAN tag, changing MAC addresses and forwarding packets
    on the local interface.

The value used for the VLAN tag then depends only on routers A and B,
then different packets from different communications will be tagged
with the same value between A and B.

** 3.2.3 Advanced mobility

It's important to keep in mind that the mobile host may not only go
from one network to another but may roam across many different ones
and also go back to previously visited network. Therefore the tunnel
establishement algorithm described before is a trade between having a
simple sequence of operations to be done by the controller and try not
to make switches flow table soaring after host have roamed for a
while, that is why shared tunnel solution has be selected.

**** a. Subsequent Handover

When the mobile node after having left its home network A to go to
network B, changes again of network and goes to network C. There are
now two address for which mobility have to be ensured : the one
acquired in network A and the one acquired in B, that means that two
tunnels have to be set up : one between switch A and switch C and
another between switch B and switch C, moreover the previously tunnel
from A to B must not be used anymore for handlin mobility of this
mobile node. Once installed into a switch a flow can be updated when a
new flow whith the same matching criterias is pushed to the switch,
this is what happens when the host gets to network C. At this time two
tunnel flows are installed into switch A : one ensures that every
packet going to the mobile node address is forwarded in a vlan tunnel
toward B, let's call this flow FA1. The other one ensures that every
packets going from the vlan tunnel is piped to the routing table,
let's call it FA2. When the mobile node reaches network C, a new vlan
tunnel is set up between switches A and C, FA1 is then updated because
a new flow matching every packets going to mobile node address is
pushed, and makes the switch A forwards them into the new vlan-tunnel
toward C. The second new pushed flow matches packets based on a new
vlan tag, then it doesn't update FA2 as tunnels between A and B and
between A and C use different tag. Then switch A has now 3 flows in
its tunnel flow table : two of them handle host mobility into network
C and the last one is now useless for the considered host but still
important to handle mobility of other mobile nodes that have moved
from network A to network B.

The two new flows pushed to switch B when the mobile node gets in
network C are exactely analog to the one pushed to switch A when the
host moved to network B, but they are associated with the new vlan
tunnel between switch B and switch C. One of the two already existing
flows related to the vlan tunnel established with switch A, was in
charge of forwarding packets caming from the tunnel to network B
interface, let's call it FB1. The other one was matching packets with
mobile node address as source address and sending them into the
tunnel, let's call it FB2. As the mobile node is not anymore in
network B, FB2 becomes completely useless, but FB1 is still used for
other mobile nodes that have moved from network A to network B.

Two pairs of flow are then pushed to switch C they are analog to the
pair pushed to switch B when the mobile node reached network B from
network A, but one pair is related to the tunnel between switch A and
switch C and the other to the tunnel between switch B and switch C.

**** b. Complexity:

In this scenario of subsequent handover, when the node gets to network
C, 8 flows are pushed by the controller, and every time a mobile node
moves to a new network, n time 4 flows will be pushed with n the
number of visited networks. Indeed the fact of having simple flow
pushing algorithm makes the number of OpenFlow messages quite
important. However, our method doesn't present a great space
complexity regading to switches flow tables, and especially for the
first flow table. Indeed as tunnel are shared, pushed flows are still
usefull for other mobile node except the previously called FB2 which
becomes unused untill the mobile node is back to network B.

**** c. Back to a visited network 

If our mobile node, after having visited network C, keeps roaming and
goes back to network B, mobility of the the address acquired in
network A and of the one acquired in network C have to be ensured,
moreover packets going to the address that the mobile node has forged
in network B doesn't have to be transfered in a tunnel anymore.  Then
two flows are pushed to switch A and two others are pushed to switch B
and as they are exactly the same as the one pushed when the host moved
first from network A to network B (the vlan tag is still the same), there
won't have new flows in switch A and switch B's flow table.

Two other pairs of flow are pushed to switch C and switch B again,
but as we said tunnel are unidirectionnal in the sense that one
tunnel ensure mobility between two switch for a given direction, then
two more entries are written in both switch B and switch C's flow
table.

Packets going to the address that the mobile node forged into
newtork B when it got there for the first time were matched by a flow
entry that sent them into the tunnel between switch B and switch C.
Now this flow entry is updated with the push of a same matching flow
that forward packets on the local network interface of the switch.

**** d. complexity

When the mobile nodes goes back to a previously visited network, old
flow entries are used again, and then flow table size doesn't become
very high. As each mobile node is associated to the list of the
networks that he visited, if it goes back to previous networks,
several networks can occur multiple time on the list, then in order to
avoid subsequent flow pushing dealing with the same tunnel the
controller when handling mobile node handover, keeps in memory wich
tunnel has already be updated in order not to send flows updating an
already updated tunnel.

* 3.3 Observations and results 
** Introduction
This part is following the steps of what is suposed to be presented
during the final presentation, its role is to illustrate and make
clearer the concepts presented in the previous section.

** 3.3.1 Network topology and simple ping
*** a. Topology
Let's considere a strictly related newtork of 4 routers where each
one of them has a host linked to its local interface as shown below:
**** TODO INSERT NETWORK PLAN AND PROVIDE CODE IN APPENDIX
Once both mininet and the controller are launched, after few seconds
host get configured with global IPv6 addresses:
**** TODO insert picture h1_autoconfiguration.png
     
*** b. Simple Ping
To enable host to send messages, thay have to be given a default
route, here the local router is the default route, 
**** TODO insert picture hosts_routeConfiguration.png
From now hosts are able to ping each other, the first ping messages
won't be conveyed to their destination as the flow are getting pushed
to switches but once they received all the information from the
controller, messages are well relayed. Here is an example with h2
pinging h1's address : 
**** TODO insert picture h2_ping_h1.png


The first message of this series of ping has triggered flow pushing
to the second flow table of s1 and s2, at the begining those tables
were empty and now they get populated with the occurence of new ping
messages, here is the content of the flow tables of s2.
**** TODO insert s2_dumpflows.png

** 3.3.2 Simulating one hop mobility

As making hosts move from one router to another with mininet looks
possible to implement in a python script, but not with command line
instruction. The idea to overcome this issue is to use IP and MAC
spoofing inside the network. Indeed let's configure h3 with the same
addresses as h1 while h1 is turned of, as h3 presents h1 identifiers
the controller will treat it as if it was h1.

**** TODO insert h3_spoofs_h1.png

Now if h2 pings again h1's address, ping messages are still well
exchanged but now the ttl of the ping response is equal to 61 whearas
it was equal to 62 before, that means that there is one more hope now
on the path from h2 to h1's address. Using a packet sniffer it is
possible to see ping messages going from s2 to s1 and then being
relayed to s3, h1's address mobility is then provided.
**** TODO insert picture h2_ping_h1spoofed.png

Ping messages are now received and treated by h3 that now plays the
role of h1 as we can see from a packet capture on h3's interface:

**** TODO insert picture h3_tcpdump.png

Flow tables have been updated, the first flow table of s1 is now
containing two flows that transfer packets going to h1's address in
the tunnel toward s3.

**** TODO insert s1_dumpflows.png

** 3.3.3 Simulating advanced mobility

Let's now turn h3 off and make h4 impersonate h1 exactly as the same
way we did before with h3, the controller will then believe that h1
has now moved from s3 coverage to s4 coverage.  Then ping messages go
now through a new tunnel between s1 and s4, and second tunnel is set
up between s3 and s4, we can retrieve them with the dump of s4 flow
table:

**** TODO insert s4_dumpflows.png

When the mobile node moves back under s3 coverage after having
visited s4 network, flow tables are updates and ping messages are now
routed again to s3 and s3 now forwards packets going to h1'address
not anymore on a tunnel but on its local interface, here is s3 flow
table when h3 spoofes h1 again:

**** TODO insert s3_dumpflows.png  


* Part IV Futur Enhancements and Conclusion
* ----------------------------------------------------------------------

* 4.1 Enhancements
** 4.1.1 Network topology constrains
*** a. Stricly related switch backbone
A major enhancement of the current program would consist in making the
controller more open to different network topology, currently all the
switches of the network has to be linked together. This simplification
has been choosed in order to keep routing alorithm simple, but it's a
hypotesis that is quite far from real world network topology. In the
program the algorithm constists in finding the switch that host the
destination node thanks to the destination address of the packet, and
then find the interface to which the link leading to this switch is
plugged from the link table. 

A solution can be to have a topology with the shape of a star, with
one switch at the middle is linked to all the other around him, and
the surrounding switch just forward packets to it as if it was their
default gateway. There controller would have to care about the switch
it's dealing with because routing policies would't be the same for all
the switches.

*** b. Allow multiple local interface

A second constrain is that only the first interface of each switch
must be dedicated to its local network. As mininet doesn't allow two
hosts sharing the same switch interface, our program doesn't work with
a network where multiple host are behind the same switch.

Adding several local interfaces involve many changes on the program as
switches would have to resolve output interface for packets going to
hosts thay are hosting. If mobility is not ensured, it's simple but
for a given switch when packets are comming from a shared tunnel with
a destination address forged in another network, this switch has to
know how to route it toward the right local interface. But if the
same packet is comming to the switch but not through a tunnel this
packet has to be forwarded on the backbone, to the associated switch.
This involves to introduce two different and independant routing
rules, that can be done with a third table.

Moreover the case of an host that changes the interface to which it
is linked to a switch has to be handled, all the flows of the third
table related to host addresses would have to be updated.
 
*** c. Make the controller independant of interface order

Another optimisation that comes along with the previous one would be
to make the conrtroller completly independant with how switch
interface are configured if they are linked to other switches of host.
The one toward the switches can be obtained from the topology data
structure build by mininet and the other can be spotted out at the
reception of router or neighbor solicitation messages.

** 4.1.2 Controller algorithms 
*** a. Having less flow to push
We already said that each time a node moves to a new network after
having visited n networks, 4 time n flows has to be pushed down by the
controller. Then after a while it can turns out to be lot of flow to
send for the controller. In order to limit this number a new way to
handle mobility would be only to set up a tunnel between the switch
of the just network left by the host and the one of the newtork just
reached, then mobility would be ensured with this series of tunnel
bound one after the other one among which switches would forward
packets going to the address the mobile node has forged under their
coverage but also packets going to the address the mobile has forged in
the network visited before : comming from the serie of tunnel. 

*** b. Handling the first packets of flow
As routing flows are pushed reactively the first packets of a serie
that triggers a flow pushing are lost. This can be avoided in
implementing a buffering mechanism inside the controller or in making
it tell switches to forward those packets to their destination
while flows are being set up.

*** c. Handling other types than icmpv6
Flows pushed to both the first or the second flow table of each switch
match ipv6 ping messages packet, this has to be changed in the future
to allow other types of message to be treated. The question then is
gather all the network traffic type in one general matching flows or
assign specific flows for each supported protocol.

*** TODO d. Handle address confict within the same sub network
    with other host, we suppose that the node compute it global ip@
    the same way as the controller
*** d. Introducing access control to mobility service
As mobility management is presented as a service it would be nice to
control which user can use it. Then the implementation of a policy
decision an enforcement entity could be done which would be consulted
when a new user shows up in the network. The authentication can be
first based on the mac address, and then on more advanced criterias. 

** 4.1.3 Interaction with mininet
*** a. Make hosts move for real
Yet a way to make host moves from one switch to antother within the
mininet virtual network hasn't been found, that is why our way was to
trick the SDN controller with addresses spoofing. But as hosts doesn't
properly move in our simulation we do not really know how the system
really reacts and may be the messages exchanged between the mobile
node and the switch are not exactelly the same. It appears that
allocating several local network interfaces on switches may help but
this involve changes of the controller behaviour as described
before.

*** b. From comand line to a batch program
Our demonstration has been done in typing one by one all the mininet
instructions that turns out to be quite the same, it would make the
interaction with mininet easier and faster especially during the test
phases to load once an instruction file instead of writing them all
every single time. 
 
* 4.2 Conclusion
** 4.2.1 Status and scope of the program
what is it doing? limitation? why is it limited?
** 4.2.2 Context, how can it be used in real life 
** 4.2.3 Personal impressions
